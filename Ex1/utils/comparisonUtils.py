import os
import numpy as np
import matplotlib.pyplot as plt

ORDER_COLORS = {1: 'blue', 3: 'red', 10: 'purple'}
DATASET_SCATTER_COLORS = {'A': 'orange', 'B': 'green'}

def comparisonFileReader(filepath):
    """Read comparison output generated by comparison exercises, supporting test points and curves."""
    data_x, data_a, data_b = [], [], []
    test_x, test_a, test_b = [], [], []
    curve_x, curve_a, curve_b = [], [], []

    methods = {}
    orders = set()

    current_method = None
    prediction_mapping = []
    test_prediction_mapping = []
    current_table = None
    reading_test_points = False
    reading_test_curve = False

    with open(filepath, 'r') as f:
        for raw_line in f:
            line = raw_line.strip()
            if not line:
                if not reading_test_points and not reading_test_curve:
                    current_table = None
                continue

            if line.startswith('#'):
                stripped = line[1:].strip()
                reading_test_points = False
                reading_test_curve = False

                if stripped.startswith('Method:'):
                    current_method = stripped.split(':', 1)[1].strip()
                    methods[current_method] = {
                        'params': {'A': {}, 'B': {}},
                        'predictions': {'A': {}, 'B': {}},
                        'test_predictions': {'A': {}, 'B': {}},
                        'x_pred': [],
                        'x_test': []
                    }
                    prediction_mapping = []
                    test_prediction_mapping = []
                    current_table = None
                elif stripped.startswith('Order') and current_method is not None:
                    header_tokens = stripped.split()
                    if len(header_tokens) >= 3:
                        order = int(header_tokens[1])
                        dataset_label = header_tokens[2].rstrip(':')
                        values_part = line.split(':', 1)[1].strip()
                        values = [float(x) for x in values_part.split()] if values_part else []
                        methods[current_method]['params'][dataset_label][order] = values
                        orders.add(order)
                elif stripped.startswith('Test points'):
                    current_method = None
                    reading_test_points = True
                elif stripped.startswith('Test curve'):
                    current_method = None
                    reading_test_curve = True
                else:
                    pass
                continue

            tokens = line.split()
            if not tokens:
                continue

            if reading_test_points:
                values = [float(x) for x in tokens]
                if len(values) >= 3:
                    test_x.append(values[0])
                    test_a.append(values[1])
                    test_b.append(values[2])
                continue

            if reading_test_curve:
                values = [float(x) for x in tokens]
                if len(values) >= 3:
                    curve_x.append(values[0])
                    curve_a.append(values[1])
                    curve_b.append(values[2])
                continue

            if current_method is None:
                if tokens[0] in ('x', 'x_pred', 'x_test'):
                    continue
                values = [float(x) for x in tokens]
                if len(values) >= 3:
                    data_x.append(values[0])
                    data_a.append(values[1])
                    data_b.append(values[2])
                continue

            if tokens[0] == 'x_pred':
                current_table = 'pred'
                prediction_mapping = []
                methods[current_method]['x_pred'] = []
                for token in tokens[1:]:
                    if '_' not in token:
                        continue
                    fit_part, dataset_label = token.split('_')
                    order = int(fit_part.replace('fit', ''))
                    orders.add(order)
                    prediction_mapping.append((dataset_label, order))
                    if order not in methods[current_method]['predictions'][dataset_label]:
                        methods[current_method]['predictions'][dataset_label][order] = []
                continue

            if tokens[0] == 'x_test':
                current_table = 'test'
                test_prediction_mapping = []
                methods[current_method]['x_test'] = []
                for token in tokens[1:]:
                    if '_' not in token:
                        continue
                    fit_part, dataset_label = token.split('_')
                    order = int(fit_part.replace('testfit', ''))
                    orders.add(order)
                    test_prediction_mapping.append((dataset_label, order))
                    if order not in methods[current_method]['test_predictions'][dataset_label]:
                        methods[current_method]['test_predictions'][dataset_label][order] = []
                continue

            values = [float(x) for x in tokens]
            if current_table == 'pred' and prediction_mapping:
                methods[current_method]['x_pred'].append(values[0])
                for (dataset_label, order), value in zip(prediction_mapping, values[1:]):
                    methods[current_method]['predictions'][dataset_label][order].append(value)
            elif current_table == 'test' and test_prediction_mapping:
                methods[current_method]['x_test'].append(values[0])
                for (dataset_label, order), value in zip(test_prediction_mapping, values[1:]):
                    methods[current_method]['test_predictions'][dataset_label][order].append(value)
            else:
                if len(values) >= 3:
                    data_x.append(values[0])
                    data_a.append(values[1])
                    data_b.append(values[2])

    return {
        'data': {
            'x': np.array(data_x),
            'datapointsA': np.array(data_a),
            'datapointsB': np.array(data_b)
        },
        'test_data': {
            'x': np.array(test_x),
            'A': np.array(test_a),
            'B': np.array(test_b)
        },
        'test_curve': {
            'x': np.array(curve_x),
            'A': np.array(curve_a),
            'B': np.array(curve_b)
        },
        'methods': methods,
        'orders': sorted(orders)
    }


def _plot_comparison_fit(ax, x_train, y_train, method_data, orders, dataset_label, method_name,
                         x_bounds, y_bounds, test_data=None, test_curve=None):
    ax.scatter(x_train, y_train, color=DATASET_SCATTER_COLORS.get(dataset_label, 'gray'),
               alpha=0.7, s=45, label=f'Dataset {dataset_label}')

    if test_data is not None and test_data['x'].size > 0:
        y_test = test_data['A'] if dataset_label == 'A' else test_data['B']
        ax.scatter(test_data['x'], y_test, marker='s', s=55, facecolor='none', edgecolor='black',
                   linewidths=1.2, alpha=0.85, label=f'Test data {dataset_label}')

    if test_curve is not None and test_curve['x'].size > 0:
        y_curve = test_curve['A'] if dataset_label == 'A' else test_curve['B']
        ax.plot(test_curve['x'], y_curve, linestyle='--', color='black', linewidth=2,
                label='True curve')

    x_pred = np.array(method_data.get('x_pred', []))
    for order in orders:
        preds_for_dataset = method_data['predictions'][dataset_label]
        if order not in preds_for_dataset:
            continue
        color = ORDER_COLORS.get(order, plt.cm.tab10(order % 10))
        y_pred = np.array(preds_for_dataset[order])
        if x_pred.size == 0 or y_pred.size == 0:
            continue
        ax.plot(x_pred, y_pred, color=color, linewidth=2, label=f'Order {order}')

    x_test_pred = np.array(method_data.get('x_test', []))
    if x_test_pred.size > 0:
        preds_for_dataset = method_data.get('test_predictions', {}).get(dataset_label, {})
        for order in orders:
            if order not in preds_for_dataset:
                continue
            y_test_pred = np.array(preds_for_dataset[order])
            if y_test_pred.size == 0:
                continue
            color = ORDER_COLORS.get(order, plt.cm.tab10(order % 10))
            ax.scatter(x_test_pred, y_test_pred, marker='^', s=45, color=color,
                       alpha=0.65, label='_nolegend_', zorder=5)

    ax.set_xlabel('x')
    ax.set_ylabel('y')
    ax.set_title(f'{method_name} • Dataset {dataset_label}')
    ax.grid(True, alpha=0.3)
    if x_bounds is not None:
        ax.set_xlim(*x_bounds)
    if y_bounds is not None:
        ax.set_ylim(*y_bounds)
    ax.legend()


def _plot_comparison_parameters(ax, method_data, orders, dataset_label, method_name):
    params_dict = method_data['params'][dataset_label]
    x_positions, heights, colors, labels = [], [], [], []
    current_x = 0

    for order in orders:
        values = params_dict.get(order, [])
        if not values:
            continue
        for idx, val in enumerate(values):
            x_positions.append(current_x)
            heights.append(val)
            colors.append(ORDER_COLORS.get(order, 'gray'))
            labels.append(f'θ{idx}\nord {order}')
            current_x += 1
        current_x += 1  # spacing between orders

    if not x_positions:
        ax.text(0.5, 0.5, 'No parameters', ha='center', va='center')
        ax.axis('off')
        return

    ax.bar(x_positions, heights, color=colors, alpha=0.7)
    ax.set_xticks(x_positions)
    ax.set_xticklabels(labels, rotation=45, ha='right', fontsize=8)
    ax.set_ylabel('Parameter values')
    ax.set_title(f'{method_name} • Parameters {dataset_label}')
    ax.grid(True, alpha=0.3, axis='y')

    legend_handles = [
        plt.Rectangle((0, 0), 1, 1, color=ORDER_COLORS.get(order, 'gray'), alpha=0.7, label=f'Order {order}')
        for order in orders if order in params_dict
    ]
    if legend_handles:
        ax.legend(handles=legend_handles, loc='upper right')

def plotComparisonFigure(filepath, title, output_path=None):
    comparison = comparisonFileReader(filepath)
    data = comparison['data']
    test_data = comparison.get('test_data', {'x': np.array([]), 'A': np.array([]), 'B': np.array([])})
    test_curve = comparison.get('test_curve', {'x': np.array([]), 'A': np.array([]), 'B': np.array([])})
    methods = list(comparison['methods'].items())
    orders = comparison['orders']

    if len(methods) != 2:
        raise ValueError(f"Expected exactly two methods in comparison file, found {len(methods)}")

    x_train = data['x']
    y_train_A = data['datapointsA']
    y_train_B = data['datapointsB']

    def _bounds_from_arrays(arrays, padding_ratio, default_pad):
        collected = []
        for arr in arrays:
            if arr is None:
                continue
            arr_np = np.asarray(arr)
            if arr_np.size > 0:
                collected.append(arr_np)
        if not collected:
            return None
        combined = np.concatenate(collected)
        val_min, val_max = combined.min(), combined.max()
        if np.isclose(val_min, val_max):
            pad = default_pad
        else:
            pad = (val_max - val_min) * padding_ratio
        return (val_min - pad, val_max + pad)

    x_arrays = [x_train, test_data['x'], test_curve['x']]
    for _, method_data in methods:
        if method_data.get('x_pred'):
            x_arrays.append(method_data['x_pred'])
        if method_data.get('x_test'):
            x_arrays.append(method_data['x_test'])
    x_bounds = _bounds_from_arrays(x_arrays, padding_ratio=0.1, default_pad=0.1)

    yA_arrays = [y_train_A, test_data['A'], test_curve['A']]
    yB_arrays = [y_train_B, test_data['B'], test_curve['B']]
    for _, method_data in methods:
        for values in method_data['predictions']['A'].values():
            yA_arrays.append(values)
        for values in method_data['predictions']['B'].values():
            yB_arrays.append(values)
        for values in method_data.get('test_predictions', {}).get('A', {}).values():
            yA_arrays.append(values)
        for values in method_data.get('test_predictions', {}).get('B', {}).values():
            yB_arrays.append(values)

    yA_bounds = _bounds_from_arrays(yA_arrays, padding_ratio=0.15, default_pad=0.1)
    yB_bounds = _bounds_from_arrays(yB_arrays, padding_ratio=0.15, default_pad=0.1)

    fig, axes = plt.subplots(4, 2, figsize=(18, 24))

    for idx, (method_name, method_data) in enumerate(methods):
        row_offset = idx * 2
        _plot_comparison_fit(axes[row_offset, 0], x_train, y_train_A, method_data, orders, 'A', method_name,
                             x_bounds, yA_bounds, test_data, test_curve)
        _plot_comparison_fit(axes[row_offset, 1], x_train, y_train_B, method_data, orders, 'B', method_name,
                             x_bounds, yB_bounds, test_data, test_curve)
        _plot_comparison_parameters(axes[row_offset + 1, 0], method_data, orders, 'A', method_name)
        _plot_comparison_parameters(axes[row_offset + 1, 1], method_data, orders, 'B', method_name)

    fig.suptitle(title, fontsize=18)
    fig.tight_layout(rect=[0, 0, 1, 0.97])

    if output_path:
        plt.savefig(output_path, dpi=300, bbox_inches='tight')

    plt.show()